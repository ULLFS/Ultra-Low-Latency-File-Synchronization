mod args;
use anyhow::Error;
use aya::{include_bytes_aligned, maps::{Array, AsyncPerfEventArray, PerCpuArray}, programs::KProbe, util::online_cpus, Ebpf};
use bytes::{Buf, BytesMut};
use serde_json::Value;
use structopt::StructOpt;
#[allow(unused_imports)]
use log::*;
use crate::args::Args;
use std::{fs, io::BufReader, process, sync::Arc, time::Duration};
use steady_state::*;
mod client;
pub mod filehasher;
pub mod fileFilter;
pub mod createPacket;
pub mod fileDifs;
pub mod hashFileDif;
pub mod client_tcp;
mod actor {
    
        pub mod ebpf_listener;
        // pub mod tcp_worker;
        // pub mod handle_client;
}

fn main() {
    let opt = Args::from_args();

    let service_executable_name = "ullfs";
    let service_user = "ullfs_user";
    let systemd_command = SystemdBuilder::process_systemd_commands(  opt.systemd_action()
                                                   , opt.to_cli_string(service_executable_name).as_str()
                                                   , service_user);

    if !systemd_command {
        info!("Starting up");
        let mut graph = build_graph(GraphBuilder::for_production()
                                .with_telemtry_production_rate_ms(200)
                                .build(opt.clone()) );

        graph.start();


        graph.block_until_stopped(Duration::from_secs(2));
    }
}

fn build_graph(mut graph: Graph) -> Graph {

    //this common root of the channel builder allows for common config of all channels
    let base_channel_builder = graph.channel_builder()
        .with_type()
        .with_line_expansion(1.0f32);

    //this common root of the actor builder allows for common config of all actors
    let base_actor_builder = graph.actor_builder()
        .with_mcpu_percentile(Percentile::p80())
        .with_load_percentile(Percentile::p80());

    //build channels
    //{Index, Value, Flags}
    // let t = tokio::signal::ctrl_c().await;
    // println!("Exiting");
    
    //build actors
    
    {
        
        let state = new_state();
        let ebpf_tx: Vec<SteadyTx<Box<String>>> = Vec::new();
        let ebpf_rx: Vec<SteadyRx<Box<String>>> = Vec::new();
        // let mut tcp_msg_rx = tcp_msg_rx.lock().await;
        // println!("Running ebpf_builder"); // Why is ebpf_builder running twice?

    // let dif = fileDifs::FileData::get_instance();
    // let old = dif.get_file_delta("/home/zmanjaroschool/TestDir/testDif.txt");
    // let t = tokio::signal::ctrl_c().await;
    // let new = dif.get_file_delta("/home/zmanjaroschool/TestDir/testDif.txt");
    // println!("Old size: {}. New size: {}", old.1.len(), new.1.len());
    // println!("New start: {}. New end: {}", new.0, new.2);
    // return Ok(());
    // env_logger::init();
    
    // Bump the memlock rlimit. This is needed for older kernels that don't use the
    // new memcg based accounting, see https://lwn.net/Articles/837122/
    let rlim = libc::rlimit {
        rlim_cur: libc::RLIM_INFINITY,
        rlim_max: libc::RLIM_INFINITY,
    };
    let ret = unsafe { libc::setrlimit(libc::RLIMIT_MEMLOCK, &rlim) };
    if ret != 0 {
        debug!("remove limit on locked memory failed, ret is: {}", ret);
    }

    // This will include your eBPF object file as raw bytes at compile-time and load it at
    // runtime. This approach is recommended for most real-world use cases. If you would
    // like to specify the eBPF program at runtime rather than at compile-time, you can
    // reach for `Bpf::load_file` instead.
        #[cfg(debug_assertions)]
        let mut bpf: Ebpf = Ebpf::load(include_bytes_aligned!(
            "../../target/bpfel-unknown-none/debug/ullfs"
        )).expect("Failed to load ebpf code");
        #[cfg(not(debug_assertions))]
        let mut bpf: Ebpf = Ebpf::load(include_bytes_aligned!(
            "../../target/bpfel-unknown-none/release/ullfs"
        ))?;
        // if let Err(e) = BpfLogger::init(&mut bpf) {
        //     // This can happen if you remove all log statements from your eBPF program.
        //     warn!("failed to initialize eBPF logger: {}", e);
        // }

        {
            let program: &mut KProbe = bpf.program_mut("vfs_write").unwrap().try_into().expect("Failed to create mutable program");
            program.load().expect("Failed to create mutable program");
            program.attach("vfs_write", 0).expect("Failed to attach to vfs_write");
        }

        {
            let program: &mut KProbe = bpf.program_mut("vfs_mkdir").unwrap().try_into().expect("Failed to create mutable program");
            program.load().expect("Failed to create mutable program");
            program.attach("vfs_mkdir", 0).expect("Failed to attach to vfs_mkdir");
        }

        {
            let program: &mut KProbe = bpf.program_mut("vfs_rmdir").unwrap().try_into().expect("Failed to create mutable program for vfs_rmdir");
            program.load().expect("failed to load for vfs_rmdir");
            program.attach("vfs_rmdir", 0).expect("Failed to attach to vfs_rmdir");
        }

        {
            let program: &mut KProbe = bpf.program_mut("vfs_rename").unwrap().try_into().expect("Failed to create mutable program");
            program.load().expect("Failed to load program for vfs_rename");
            program.attach("vfs_rename", 0).expect("Failed to attach ebpf program to vfs_rename");
        }

        //*Lets read the config file */
        let conf_file : fs::File = match fs::File::open("./config.json"){
            Ok(x) => x,
            Err(e) => {
                panic!("Error: config.json missing or destroyed.\n{}", e)
            }
        };
        // Convert to buffer for serde_json
        let reader = BufReader::new(conf_file);
        let conf : Value = match serde_json::from_reader(reader){
            Ok(x) => x,
            Err(e) => {
                panic!("Error: config.json structure damaged.\n{}", e);
            }
        }; 
        // Read from the json structure (Basically acts as a hashmap at this point)
        let watch_dir : &str = match &conf["watch_dir"].as_str() {
            None => {
                panic!("Error: watch_dir was not a string in config.json");
            }
            Some(x) => x,
        };
        let watch_dir_string : String = String::from(watch_dir);
        // Debugging data
        // println!("Conf file output: {}", &watch_dir);
        // Get the metadata from the watch_dirvfs_mkdir
        let w_dir = match fs::metadata(watch_dir){
            Ok(x) => x,
            Err(e) => {
                panic!("Error: Directory {} not found, something must be wrong with your config file\n{}", &watch_dir, e);
            }
        };
        // Get the inode from the metadata
        let block_addr: u64 = std::os::linux::fs::MetadataExt::st_ino(&w_dir);
        println!("Block Address: {}", block_addr);
        {
            // Initialize the inode map
            let mut inodesdata: Array<_, u64> = Array::try_from(bpf.take_map("INODEDATA").unwrap()).expect("Failed to take inodesdata");
            inodesdata.set(0, block_addr, 0).expect("Failed to set inodesdata");
        }
        {
            // Initialize the program data map
            // ID 0: PID for this program
            let mut progdata: Array<_, u64> = Array::try_from(bpf.take_map("PROGDATA").unwrap()).expect("Failed to take from array");
            let progid = process::id();
            let progid_64 : u64 = u64::from(progid);
            progdata.set(0, progid_64, 0).expect("Failed to set progdata");
        }
        for cpu_id in online_cpus().map_err(|(_, error)| error).expect("Failed to get online cpus"){
            let (ebpf_listener_conn_tx: LazySteadyTx<Box<String>>, ebpf_listener_conn_rx : LazySteadyRx<Box<String>>) = base_channel_builder.build();
            // ebpf_tx.push(ebpf_listener_conn_tx.clone());
            // ebpf_rx.push(ebpf_listener_conn_rx.clone());
            base_actor_builder.with_name("EbpfListenerActor")
                 .build( move |context| actor::ebpf_listener::run(context
                                            , ebpf_listener_conn_tx.clone()
                                            , state.clone(),
                                            &mut bpf,
                                        cpu_id)
                  , &mut Threading::Spawn );
        }  
     
    }
    
    
    graph
}

#[cfg(test)]
mod graph_tests {
    use async_std::test;
    use steady_state::*;
    use std::time::Duration;
    use crate::args::Args;
    use crate::build_graph;
    use std::ops::DerefMut;
    use futures_timer::Delay;

    #[test]
    async fn test_graph_one() {

            let test_ops = Args {
                loglevel: "debug".to_string(),
                systemd_install: false,
                systemd_uninstall: false,
            };
            let mut graph = build_graph( GraphBuilder::for_testing().build(test_ops.clone()) );
            graph.start();
            let mut guard = graph.sidechannel_director().await;
            let g = guard.deref_mut();
            assert!(g.is_some(), "Internal error, this is a test so this back channel should have been created already");
            if let Some(_plane) = g {

             //NOTE: to ensure the node_call is for the correct channel for a given actor unique types for each channel are required

            

              // //TODO:   if needed you may want to add a delay right here to allow the graph to process the message
              Delay::new(Duration::from_millis(100)).await;

             

            }
            drop(guard);
            graph.request_stop();
            graph.block_until_stopped(Duration::from_secs(3));
        }
    }
